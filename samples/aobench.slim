
const i32 WIDTH = 256;
const i32 HEIGHT = 256;

const i32 NSUBSAMPLES = 2;
const i32 NAO_SAMPLES = 8;

type Vec = struct {
    f32 x;
    f32 y;
    f32 z;
};

type Isect = struct {
    f32 t;
    Vec p;
    Vec n;
    i32 hit;
};

type Sphere = struct {
    Vec center;
    f32 radius;
};

type Plane = struct {
    Vec p;
    Vec n;
};

type Ray = struct {
    Vec org;
    Vec dir;
};

private [Sphere; 3] spheres;
private Plane plane;


fn vdot f32(varying Vec v0, varying Vec v1) {
    return (v0#0 * v1#0 + v0#1 * v1#1 + v0#2 * v1#2);
}

fn vcross Vec(varying Vec v0, varying Vec v1) {
    val x = v0#1 * v1#2 - v0#2 * v1#1;
    val y = v0#2 * v1#0 - v0#0 * v1#2;
    val z = v0#0 * v1#1 - v0#1 * v1#0;
    return (composite Vec(x, y, z));
}

fn vnormalize Vec(varying Vec v) {
    val length = sqrt(vdot(v, v));
    if (abs(length) > 1e-16) {
        return (composite Vec(v#0 / length, v#1 / length, v#2 / length));
    }
    return (v);
}

fn ray_sphere_intersect(varying ptr private Isect isect, varying Ray ray, varying Sphere sphere) {
    var Vec rs = composite Vec(0, 0, 0);

    rs#0 = ray#0#0 - sphere#0#0;
    rs#1 = ray#0#1 - sphere#0#1;
    rs#2 = ray#0#2 - sphere#0#2;

    val B = vdot(rs, ray#1);
    val C = vdot(rs, rs) - sphere#1 * sphere#1;
    val D = B * B - C;

    if (D > 0.0) {
        val t = -B - sqrt(D);

        // TODO short-circuit operator
        if ((t > 0.0) & (t < (*isect)#0)) {
            (*isect)#0 = t;
            (*isect)#3 = 1;

            (*isect)#1#0 = ray#0#0 + ray#1#0 * t;
            (*isect)#1#1 = ray#0#1 + ray#1#1 * t;
            (*isect)#1#2 = ray#0#2 + ray#1#2 * t;

            (*isect)#2#0 = (*isect)#1#0 - sphere#0#0;
            (*isect)#2#1 = (*isect)#1#1 - sphere#0#1;
            (*isect)#2#2 = (*isect)#1#2 - sphere#0#2;

            (*isect)#2 = vnormalize((*isect)#2);
        }
    }
}


fn ray_plane_intersect(varying ptr private Isect isect, varying Ray ray, varying Plane plane) {
    val d = -vdot(plane#0, plane#1);
    val v = vdot(ray#1, plane#1);

    if (abs(v) < 1e-16) {
        return();
    }

    val t = -(vdot(ray#0, plane#1) + d) / v;

    if ((t > 0.0) & (t < (*isect)#0)) {
        (*isect)#0 = t;
        (*isect)#3 = 1;

        (*isect)#1#0 = ray#0#0 + ray#1#0 * t;
        (*isect)#1#1 = ray#0#1 + ray#1#1 * t;
        (*isect)#1#2 = ray#0#2 + ray#1#2 * t;

        (*isect)#2 = plane#1;
    }
}


fn orthoBasis(varying ptr private [Vec; 3] basis, varying Vec n) {
    (*basis)#2 = n;

    (*basis)#1#0 = 0.0;
    (*basis)#1#1 = 0.0;
    (*basis)#1#2 = 0.0;

    if ((n#0 < 0.6) & (n#0 > -0.6)) {
        (*basis)#1#0 = 1.0;
    } else {
        if ((n#1 < 0.6) & (n#1 > -0.6)) {
            (*basis)#1#1 = 1.0;
        } else {
            if ((n#2 < 0.6) & (n#2 > -0.6)) {
                (*basis)#1#2 = 1.0;
            } else {
                (*basis)#1#0 = 1.0;
            }
        }
    }

    (*basis)#0 = vcross((*basis)#1, (*basis)#2);
    (*basis)#0 = vnormalize((*basis)#0);

    (*basis)#1 = vcross((*basis)#2, (*basis)#0);
    (*basis)#1 = vnormalize((*basis)#1);
}


fn drand48 f32() {
    // TODO RNG
    return (1.0);
}

fn ambient_occlusion Vec(varying Isect isect) {
    val ntheta = 8; //NAO_SAMPLES;
    val nphi   = 8; //NAO_SAMPLES;
    val eps = 0.0001;
    val M_PI = 3.14159265358979323846;

    var Vec p = composite Vec(0, 0, 0);

    p#0 = isect#1#0 + eps * isect#2#0;
    p#1 = isect#1#1 + eps * isect#2#1;
    p#2 = isect#1#2 + eps * isect#2#2;

    //var [Vec; 3] basis = composite [Vec; 3](composite Vec(0, 0, 0), composite Vec(0, 0, 0), composite Vec(0, 0, 0));
    //orthoBasis(basis, isect#2);

    var f32 occlusion = 0.0;

    val j0 = 0;
    val i0 = 0;

    loop (varying i32 j = j0, varying i32 i = i0) {
        val outer = lt(j, ntheta);
        if (outer) {
            val inner = lt(i, nphi);

            if (inner) {
                // begin loop body

                val theta = sqrt(drand48());
                val phi   = 2.0 * M_PI * drand48();

                //val x = cos(phi) * theta;
                //val y = sin(phi) * theta;
                val z = sqrt(1.0 - theta * theta);

                // local -> global
                //val rx = x * basis#0#0 + y * basis#1#0 + z * basis#2#0;
                //val ry = x * basis#0#1 + y * basis#1#1 + z * basis#2#1;
                //val rz = x * basis#0#2 + y * basis#1#2 + z * basis#2#2;

                var Ray ray = composite Ray(composite Vec(0, 0, 0), composite Vec(0, 0, 0));

                ray#0 = p;
                //ray#1#0 = rx;
                //ray#1#1 = ry;
                //ray#1#2 = rz;

                var Isect occIsect = composite Isect(0.0, composite Vec(0, 0, 0), composite Vec(0, 0, 0), 0);
                occIsect#0 = 1.0e+17;
                occIsect#3 = 0;

                //ray_sphere_intersect(&occIsect, ray, spheres#0);
                //ray_sphere_intersect(&occIsect, ray, spheres#1);
                //ray_sphere_intersect(&occIsect, ray, spheres#2);
                //ray_plane_intersect (&occIsect, ray, plane);

                if (occIsect#3 == 1) {
                    occlusion = occlusion + 1.0;
                }

                // end loop body

                val i2 = add(i, 1);
                continue(j, i2);
            } else {
                val j2 = add(j, 1);
                continue(j2, i0);
            }
        } else {
            break();
        }
        unreachable();
    }

    val s = convert[f32](ntheta * nphi);
    occlusion = (s - occlusion) / s;

    return (composite Vec(occlusion, occlusion, occlusion));
}


fn clamp u8(varying f32 f)
{
    var i32 i = convert[i32](f * 255.5);

    if (i < 0) { i = 0; }
    if (i > 255) { i = 255; }

    return (convert[u8](i));
}



fn render_pixel (varying i32 x, varying i32 y, varying i32 w, varying i32 h, varying i32 nsubsamples, varying ptr private u8 img, varying ptr private f32 fimg) {

    val v0 = 0;
    val u0 = 0;

    val off = 3 * (y * w + x);

    loop (varying i32 v = v0, varying i32 u = u0) {
        val outer = lt(v, nsubsamples);
        if (outer) {
            val inner = lt(u, nsubsamples);

            if (inner) {
                // begin loop body

                val px =  (convert[f32](x) + (convert[f32](u) / convert[f32](nsubsamples)) - (convert[f32](w) / 2.0)) / (convert[f32](w) / 2.0);
                val py = -(convert[f32](y) + (convert[f32](v) / convert[f32](nsubsamples)) - (convert[f32](h) / 2.0)) / (convert[f32](h) / 2.0);

                var Ray ray = composite Ray(composite Vec(0, 0, 0), composite Vec(0, 0, 0));

                ray#0#0 = 0.0;
                ray#0#1 = 0.0;
                ray#0#2 = 0.0;

                ray#1#0 = px;
                ray#1#1 = py;
                ray#1#2 = -1.0;
                ray#1 = vnormalize(ray#1);

                var Isect isect = composite Isect(0, composite Vec(0,0,0), composite Vec(0,0,0), 0);
                isect#0 = 1.0e+17;
                isect#3 = 0;

                //ray_sphere_intersect(&isect, ray, spheres#0);
                //ray_sphere_intersect(&isect, ray, spheres#1);
                //ray_sphere_intersect(&isect, ray, spheres#2);
                //ray_plane_intersect(&isect, ray, plane);

                if (isect#3 == 1) {
                    val col = ambient_occlusion(isect);

                    //(*fimg)#(off + 0) += col#0;
                    //(*fimg)#(off + 1) += col#1;
                    //(*fimg)#(off + 2) += col#2;
                }

                // end loop body

                val u2 = add(u, 1);
                continue(v, u2);
            } else {
                val v2 = add(v, 1);
                continue(v2, u0);
            }
        } else {
            break();
        }
        unreachable();
    }

    //(*fimg)#(off + 0) /= (f32)(nsubsamples * nsubsamples);
    //(*fimg)#(off + 1) /= (f32)(nsubsamples * nsubsamples);
    //(*fimg)#(off + 2) /= (f32)(nsubsamples * nsubsamples);

    //(*img)#(off + 0) = clamp((*fimg)#(off + 0));
    //(*img)#(off + 1) = clamp((*fimg)#(off + 1));
    //(*img)#(off + 2) = clamp((*fimg)#(off + 2));
}


@EntryPoint("compute") @WorkgroupSize(SUBGROUP_SIZE, 1, 1) fn main() {
    debug_printf("Hello World");

//    val x = workgroup_id() * workgroup_size() + workgroup_local_id();
//    val y = workgroup_id() * workgroup_size + workgroup_local_id();

//    render_pixel(x, y, WIDTH, HEIGHT, byte_buffer, float_buffer);

    return ();
}
