#ifndef SHADY_IR_H
#define SHADY_IR_H

#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>

typedef struct IrArena_ IrArena;
typedef struct Node_ Node;
typedef struct Node_ Type;
typedef unsigned int VarId;
typedef const char* String;

//////////////////////////////// Lists & Strings ////////////////////////////////

typedef struct Nodes_ {
    size_t count;
    const Node** nodes;
} Nodes;

typedef struct Strings_ {
    size_t count;
    String* strings;
} Strings;

Nodes     nodes(IrArena*, size_t count, const Node*[]);
Strings strings(IrArena*, size_t count, const char*[]);

Nodes empty(IrArena*);
Nodes singleton(const Node*);
#define mk_nodes(arena, ...) nodes(arena, sizeof((const Node*[]) { __VA_ARGS__ }) / sizeof(const Node*), (const Node*[]) { __VA_ARGS__ })

const Node* first(Nodes nodes);

Nodes append_nodes(IrArena*, Nodes, const Node*);
Nodes concat_nodes(IrArena*, Nodes, Nodes);

String string_sized(IrArena*, size_t size, const char* start);
String string(IrArena*, const char*);
String format_string(IrArena*, const char* str, ...);
String unique_name(IrArena*, const char* base_name);
String name_type_safe(IrArena*, const Type*);

//////////////////////////////// Modules ////////////////////////////////

typedef struct Module_ Module;

Module* new_module(IrArena*, String name);

IrArena* get_module_arena(const Module*);
String get_module_name(const Module*);
Nodes get_module_declarations(const Module*);

//////////////////////////////// Grammar ////////////////////////////////

// The language grammar is big enough that it deserve its own files

#include "primops.h"
#include "grammar.h"

//////////////////////////////// IR Arena ////////////////////////////////

typedef struct {
    bool name_bound;
    bool check_types;
    bool allow_fold;
    bool is_simt;

    struct {
        /// Selects which type the subgroup intrinsic primops use to manipulate masks
        enum {
            /// Uses the MaskType
            SubgroupMaskAbstract,
            /// Uses a 64-bit integer
            SubgroupMaskInt64
        } subgroup_mask_representation;

        uint32_t subgroup_size;
        uint32_t workgroup_size[3];
    } specializations;

    struct {
        IntSizes ptr_size;
        /// The base type for emulated memory
        IntSizes word_size;
    } memory;
} ArenaConfig;

ArenaConfig default_arena_config();

IrArena* new_ir_arena(ArenaConfig);
void destroy_ir_arena(IrArena*);

//////////////////////////////// Getters ////////////////////////////////

/// Get the name out of a global variable, function or constant
String get_decl_name(const Node*);

const IntLiteral* resolve_to_literal(const Node*);

int64_t get_int_literal_value(const Node*, bool sign_extend);
const char* get_string_literal(IrArena*, const Node*);

static inline bool is_physical_as(AddressSpace as) { return as <= PhysicalAddressSpacesEnd; }

/// Returns false iff pointers in that address space can contain different data at the same address
/// (amongst threads in the same subgroup)
bool is_addr_space_uniform(IrArena*, AddressSpace);

const Node* lookup_annotation(const Node* decl, const char* name);
const Node* lookup_annotation_list(Nodes, const char* name);
const Node* get_annotation_value(const Node* annotation);
Nodes get_annotation_values(const Node* annotation);
/// Gets the string literal attached to an annotation, if present.
const char* get_annotation_string_payload(const Node* annotation);
bool lookup_annotation_with_string_payload(const Node* decl, const char* annotation_name, const char* expected_payload);
bool is_annotation(const Node* node);
String get_annotation_name(const Node* node);
Nodes filter_out_annotation(IrArena*, Nodes, const char* name);

bool        is_abstraction        (const Node*);
String      get_abstraction_name  (const Node* abs);
const Node* get_abstraction_body  (const Node* abs);
Nodes       get_abstraction_params(const Node* abs);

const Node* get_let_instruction(const Node* let);
const Node* get_let_tail(const Node* let);

//////////////////////////////// Constructors ////////////////////////////////

// autogenerated node ctors
#define NODE_CTOR_DECL_1(struct_name, short_name) const Node* short_name(IrArena*, struct_name);
#define NODE_CTOR_DECL_0(struct_name, short_name) const Node* short_name(IrArena*);
#define NODE_CTOR_1(has_payload, struct_name, short_name) NODE_CTOR_DECL_##has_payload(struct_name, short_name)
#define NODE_CTOR_0(has_payload, struct_name, short_name)
#define NODE_CTOR(autogen_ctor, _, has_payload, struct_name, short_name) NODE_CTOR_##autogen_ctor(has_payload, struct_name, short_name)
NODES(NODE_CTOR)
#undef NODE_CTOR
#undef NODE_CTOR_0
#undef NODE_CTOR_1
#undef NODE_CTOR_DECL_0
#undef NODE_CTOR_DECL_1

// type ctor helpers
const Type* noret_type(IrArena*);

const Node* unit_type(IrArena*);

const Type* int8_type(IrArena*);
const Type* int16_type(IrArena*);
const Type* int32_type(IrArena*);
const Type* int64_type(IrArena*);

const Type* uint8_type(IrArena*);
const Type* uint16_type(IrArena*);
const Type* uint32_type(IrArena*);
const Type* uint64_type(IrArena*);

const Type* int8_literal(IrArena*,  int8_t i);
const Type* int16_literal(IrArena*, int16_t i);
const Type* int32_literal(IrArena*, int32_t i);
const Type* int64_literal(IrArena*, int64_t i);

const Type* uint8_literal(IrArena*,  uint8_t i);
const Type* uint16_literal(IrArena*, uint16_t i);
const Type* uint32_literal(IrArena*, uint32_t i);
const Type* uint64_literal(IrArena*, uint64_t i);

const Type* fp16_type(IrArena*);
const Type* fp32_type(IrArena*);
const Type* fp64_type(IrArena*);

// values
const Node* var(IrArena*, const Type* type, const char* name);

const Node* tuple(IrArena*, Nodes contents);
const Node* composite(IrArena*, const Type*, Nodes contents);
const Node* fn_addr_helper(IrArena*, const Node* fn);

// instructions
/// Turns a value into an 'instruction' (the enclosing let will be folded away later)
/// Useful for local rewrites
const Node* quote_helper(IrArena*, Nodes values);

// terminators
const Node* let(IrArena*, const Node* instruction, const Node* tail);
const Node* let_mut(IrArena*, const Node* instruction, const Node* tail);

// decl ctors
Node* function    (Module*, Nodes params, const char* name, Nodes annotations, Nodes return_types);
Node* constant    (Module*, Nodes annotations, const Type*, const char* name);
Node* global_var  (Module*, Nodes annotations, const Type*, String, AddressSpace);
Type* nominal_type(Module*, Nodes annotations, String name);

// basic blocks, lambdas and their helpers
Node* basic_block(IrArena*, Node* function, Nodes params, const char* name);
const Node* lambda(IrArena*, Nodes params, const Node* body);

/// Used to build a chain of let
typedef struct BodyBuilder_ BodyBuilder;
BodyBuilder* begin_body(IrArena*);

/// Appends an instruction to the builder, may apply optimisations.
/// If the arena is typed, returns a list of variables bound to the values yielded by that instruction
Nodes bind_instruction(BodyBuilder*, const Node* instruction);
Nodes bind_instruction_named(BodyBuilder*, const Node* instruction, String const output_names[]);

/// Like append instruction, but you explicitly give it information about any yielded values
/// ! In untyped arenas, you need to call this because we can't guess how many things are returned without typing info !
Nodes bind_instruction_extra_mutable(BodyBuilder*, const Node* initial_value, size_t outputs_count, Nodes* provided_types, String const output_names[]);
Nodes bind_instruction_extra(BodyBuilder*, const Node* initial_value, size_t outputs_count, Nodes* provided_types, String const output_names[]);

void bind_variables(BodyBuilder*, Nodes vars, Nodes values);

const Node* finish_body(BodyBuilder*, const Node* terminator);
void cancel_body(BodyBuilder*);
const Node* yield_values_and_wrap_in_block(BodyBuilder*, Nodes);

//////////////////////////////// Compilation ////////////////////////////////

typedef struct CompilerConfig_ {
    bool allow_frontend_syntax;
    bool dynamic_scheduling;
    uint32_t per_thread_stack_size;
    uint32_t per_subgroup_stack_size;

    struct {
        uint8_t major;
        uint8_t minor;
    } target_spirv_version;

    struct {
        bool emulate_subgroup_ops;
        bool emulate_subgroup_ops_extended_types;
        bool simt_to_explicit_simd;
        bool int64;
    } lower;

    struct {
        bool spv_shuffle_instead_of_broadcast_first;
    } hacks;

    struct {
        bool memory_accesses;
        bool stack_accesses;
        bool god_function;
        bool stack_size;
        bool subgroup_ops;
    } printf_trace;

    struct {
        int max_top_iterations;
    } shader_diagnostics;

    struct {
        bool skip_generated, skip_builtin;
    } logging;

    struct {
        uint32_t subgroup_size;
        String entry_point;
    } specialization;
} CompilerConfig;

CompilerConfig default_compiler_config();

typedef enum CompilationResult_ {
    CompilationNoError
} CompilationResult;

CompilationResult parse_files(CompilerConfig*, size_t num_files, const char** file_names, const char** files_contents, Module* module);
CompilationResult run_compiler_passes(CompilerConfig* config, Module** mod);

//////////////////////////////// Emission ////////////////////////////////

void emit_spirv(CompilerConfig* config, Module*, size_t* output_size, char** output, Module** new_mod);

typedef enum {
    C,
    GLSL,
    ISPC
} CDialect;

typedef struct {
    CompilerConfig* config;
    CDialect dialect;
    bool explicitly_sized_types;
    bool allow_compound_literals;
} CEmitterConfig;

void emit_c(CEmitterConfig config, Module*, size_t* output_size, char** output, Module** new_mod);

void dump_cfg(FILE* file, Module*);
void dump_module(Module*);
void print_module_into_str(Module*, char** str_ptr, size_t*);
void dump_node(const Node* node);

#endif
